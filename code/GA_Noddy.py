# -*- coding: utf-8 -*-
"""
Created on September 16, 2020

@author: ahinoamp@gmail.com

This script provides the basic genetic algorithm (GA) outline used for 
inverting structural geological models generated by PyNoddy.

This script is based on code from the deap project.

"""
import PSO_GA_Utilities as GA_Util
import LoadInputDataUtility as DI
import pandas as pd
import SamplingHisFileUtil as sample
import GeneralInversionUtil as GI
import SimulationUtilities as sim

import numpy as np

import deap_base as base
import deap_creator as creator
import deap_init as init


def GA_Noddy(HypP):
    
    # set up a dictionary to hold all important information, including the 
    # hyper parameters
    P={}
    P['HypP'] = HypP
    
    #1. Setup output folders and initialize parameters
    GI.setupFoldersParameters(P)    

    #2. Load the different observed data types    
    DI.loadData(P)

    #3. Set up a table where the geological model parameters are stored 
    P['ModelParamTable'] = GI.InitializeParameters(P)
    
    #4. Create class types for "individuals" in the optimisation
    # Each individual has a fitness object
    
    if(P['HypP']['DatNormMethod']=='Given'):
        dat_norm_wts=P['DatNormCoef']
    else:
        dat_norm_wts={}
        for dt in P['DataTypes']:
            dat_norm_wts[dt] = 1
    P['dat_norm_wts'] = dat_norm_wts
       
    dat_opt_wts={}
    for dt in P['DataTypes']:
        dat_opt_wts[dt] = 1./len(P['DataTypes'])
    P['dat_opt_wts'] = dat_opt_wts
        
                
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,), 
                   dat_norm_wts=dat_norm_wts, dat_opt_wts=dat_opt_wts,
                   method = P['HypP']['OptimMethod'],
                   errNorm = P['HypP']['ErrorNorm'],
                   datatypes = P['DataTypes'])
    creator.create("Individual", list, fitness=creator.FitnessMin, 
                                       LocalError ={})
    
    #5. Register functions in a toolbox of functions
    toolbox = base.Toolbox()
    GI.register_sim_functions(P['HypP'], toolbox)
    register_functions(P, toolbox)
    P['toolbox']=toolbox
    
    # Initialize pop
    pop = toolbox.pop(n=int(P['HypP']['npop']))
   
        
    cxpb=P['HypP']['IndMatingProb']
    mutpb=P['HypP']['IndMutatingProb']
    ngen=int(P['HypP']['ngen'])
    folder=P['folder']
    verbose=P['HypP']['verbose']
    vNames=(P['ModelParamTable']['EventName']+'_'+P['ModelParamTable']['Prop']).values

    ###################################
    ## Algorithm starts
    #   
    # Basic algorithm structure
    #     Initialize population
    #     for gen i in n_gen:     
    #        i. Evaluate the error of each individual element in the population
    #        ii. Selection of mating pool
    #        iii. Mating to form offspring
    #        iv. Mutating
    # 
    ###############################################
    P['iterationNum'] = -1
    
    # Evaluate the individuals (the population) with an invalid fitness
    toolbox.EvalPop(pop, P, toolbox, folder, verbose, P['ModelParamTable'],
                    vNames)


    GA_Util.VizBestInd(pop, folder, P, P['ModelParamTable'], gen=0)
          
    # Begin the generational process
    for gen in range(1, int(ngen) + 1):
                    
        # Select the next generation individuals
        offspring = toolbox.select(pop, len(pop))

        # Vary the pool of individuals
        offspring = GA_Util.varAnd(offspring, toolbox, cxpb, mutpb)

        # Evaluate the individuals with an invalid fitness
        toolbox.EvalPop(pop, P, toolbox, folder, verbose, P['ModelParamTable'],
                    vNames)
            
        # Update the hall of fame with the generated individuals
        GA_Util.VizBestInd(pop, folder, P, P['ModelParamTable'], gen)

        # Replace the current pop by the offspring
        pop[:] = offspring
   
        breakEarly = GI.CheckEarlyStop(P)
        if(breakEarly==1):
            break
        #        outputParametersScatterPlot(BigPandas, gen, P)

    GI.SaveResults2Files(P)
    
    return 1

def register_functions(P, toolbox):
    '''Create a toolbox of functions
       This way, the function always has the same name, but can have 
       different content. Allows to keep the same algorithm structure, but also
       test some interesting variations.'''
 
    std = P['ModelParamTable']['std']
    maxVList = P['ModelParamTable']['maxV']
    minVList = P['ModelParamTable']['minV']

    # population creation
    toolbox.register("SampleValues", sample.SampleParametersMinMax, P)   
    toolbox.register("individual", init.initIterate, creator.Individual,
                     toolbox.SampleValues)
    toolbox.register("pop", init.initRepeat, list, toolbox.individual)
    
    # i. Evaluation
    if(P['HypP']['ErrorType']=='Global'):
        toolbox.register("EvalPop", GA_Util.EvalPopGlobal)
    else:
        toolbox.register("EvalPop", GA_Util.EvalPopLocal)

    # ii. Selection
    if(P['HypP']['SelectionMethod']=='selStochasticUniversalSampling'):
        toolbox.register("select", GA_Util.selStochasticUniversalSamplingMinimize)
    elif(P['HypP']['SelectionMethod']=='selRoulette'):
        toolbox.register("select", GA_Util.selRouletteMinimize)
    elif(P['HypP']['SelectionMethod']=='selTournament'):
        tournamentSz = int(np.min([P['HypP']['TournamentSize'], int(P['HypP']['npop'])]))
        toolbox.register("select", GA_Util.selTournament, tournsize=tournamentSz)
        
    # iii. Mating
    if(P['HypP']['ErrorType']=='Global'):
        if(P['HypP']['MatingMethodGlobal']=='cxTwoPoint'):
            toolbox.register("mate", GA_Util.cxTwoPoint)
        elif(P['HypP']['MatingMethodGlobal']=='cxOnePoint'):
            toolbox.register("mate", GA_Util.cxOnePoint)
        elif(P['HypP']['MatingMethodGlobal']=='cxUniform'):
            toolbox.register("mate", GA_Util.cxUniform, indpb=P['HypP']['MatingSwapProb'])
        elif(P['HypP']['MatingMethodGlobal'] =='cxBlend'):
            toolbox.register("mate", GA_Util.cxBlend, alpha=P['HypP']['MatingSwapRange'])
    elif(P['HypP']['ErrorType']=='Local'):
        if(P['HypP']['MatingMethodLocal'] =='cxLocalBlend'):
            toolbox.register("mate", GA_Util.cxLocalBlend, alpha=P['HypP']['MatingSwapRange'])
        elif(P['HypP']['MatingMethodLocal'] =='cxOnePointLocal'):
            toolbox.register("mate", GA_Util.cxOnePointLocal)        
        elif(P['HypP']['MatingMethodLocal'] =='cxTwoPointLocal'):
            toolbox.register("mate", GA_Util.cxTwoPointLocal)        
        elif(P['HypP']['MatingMethodLocal'] =='cxLocalErrorPropExchange'):
            toolbox.register("mate", GA_Util.cxLocalErrorPropExchange)        
        elif(P['HypP']['MatingMethodLocal'] =='cxLocalBlendExp'):
            toolbox.register("mate", GA_Util.cxLocalBlendExp, alpha=P['HypP']['MatingSwapRange'])        

    # iv. Mutation         
    if(P['HypP']['MutatingMethod']=='mutGaussian'):
        toolbox.register("mutate", GA_Util.mutGaussianNoddy, mu=0, sigma=std, indpb=P['HypP']['PbMutateParameter'], 
                     maxVList = maxVList, minVList=minVList)
    elif(P['HypP']['MutatingMethod']=='mutPolynomialBounded'):
        toolbox.register("mutate", GA_Util.mutPolynomialBounded, indpb=P['HypP']['PbMutateParameter'], 
                     low = list(minVList), up=list(maxVList), eta=P['HypP']['Eta'])
    elif(P['HypP']['MutatingMethod']=='mutUniformFloat'):
        toolbox.register("mutate", GA_Util.mutUniformFloat, indpb=P['HypP']['PbMutateParameter'], 
                     low = list(minVList), up=list(maxVList))

    
if __name__ == "__main__":
    tasks = pd.read_pickle('Combo_Scratch/parameters.pkl')
    params = tasks.iloc[0, :]
    params = params.to_dict()
    params['MO_WeightingMethod'] = 'Equal'
    params['npop'] = 4
    params['ngen'] = 2
    GA_Noddy(params)